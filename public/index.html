<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AirParty 3D</title>
<style>
  :root { --bg:#0b0f1a; --panel:#0e1530; --ink:#e8eefc; --brand:#7ab8ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-rows:auto 1fr;height:100%}
  header{display:flex;align-items:center;gap:8px;padding:10px 12px;background:linear-gradient(180deg,#101842,#0a1026);border-bottom:1px solid rgba(150,180,255,.2)}
  header .right{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn{border:1px solid rgba(150,180,255,.3);background:#13204a;color:var(--ink);padding:7px 10px;border-radius:10px;cursor:pointer}
  .btn.primary{background:var(--brand);color:#061022;border:none;font-weight:700}
  main{display:grid;grid-template-columns:320px 1fr 320px;gap:12px;padding:12px}
  .panel{background:var(--panel);border:1px solid rgba(150,180,255,.18);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .panel header{padding:8px 10px;background:#0b1230;border-bottom:1px solid rgba(150,180,255,.18);font-weight:700}
  .panel .body{padding:10px;flex:1;overflow:auto}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{background:#0d1636;border:1px solid rgba(150,180,255,.25);color:var(--ink);border-radius:10px;padding:8px 10px}
  .list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px}
  .chip{padding:4px 8px;background:#0c1228;border:1px solid rgba(150,180,255,.2);border-radius:999px}
  #viewport{position:fixed;inset:0;display:none;background:#000}
  #hud{position:fixed;left:12px;bottom:12px;display:none;background:rgba(10,16,38,.6);border:1px solid rgba(150,180,255,.25);padding:8px 10px;border-radius:12px;font-size:13px}
  #fps{position:fixed;right:12px;bottom:12px;display:none;background:rgba(10,16,38,.6);border:1px solid rgba(150,180,255,.25);padding:6px 8px;border-radius:8px;font-size:12px}
  #compass{position:fixed;left:50%;top:12px;translate:-50% 0;background:rgba(10,16,38,.6);border:1px solid rgba(150,180,255,.25);padding:6px 10px;border-radius:999px;font-size:13px;display:none}
  #hint{position:fixed;left:50%;bottom:50%;translate:-50% 50%;font-size:14px;opacity:.75;display:none}
</style>
</head>
<body>
<div class="wrap" id="lobbyScreen">
  <header>
    <div>✈️ AirParty</div>
    <div class="right">
      <span>Room: <strong id="roomId">—</strong></span>
      <button id="btnStart" class="btn primary">Start (host)</button>
    </div>
  </header>
  <main>
    <section class="panel">
      <header>Lobby</header>
      <div class="body">
        <div class="row">
          <input id="inpName" class="input" placeholder="Your name" style="flex:1"/>
          <input id="inpColor" type="color" class="input" value="#7ab8ff" title="Plane color"/>
          <button id="btnSet" class="btn">Set</button>
          <label class="chip"><input type="checkbox" id="chkReady"> Ready</label>
        </div>
        <hr style="opacity:.25;margin:10px 0">
        <div><strong>Pilots</strong></div>
        <ul id="players" class="list"></ul>
        <hr style="opacity:.25;margin:10px 0">
        <div><strong>Chat</strong></div>
        <div id="chat" style="height:160px;overflow:auto;background:#0b1430;border:1px solid rgba(150,180,255,.2);border-radius:10px;padding:8px;"></div>
        <div class="row" style="margin-top:6px;">
          <input id="inpChat" class="input" placeholder="Message…" style="flex:1;"/>
          <button id="btnChat" class="btn">Send</button>
        </div>
      </div>
    </section>
    <section class="panel" style="grid-template-rows:auto 1fr">
      <header>Preview</header>
      <div class="body">
        <p>Controls:</p>
        <ul>
          <li>Arrow Up/Down — pitch</li>
          <li>Arrow Left/Right — yaw (auto roll level)</li>
          <li>Space — boost</li>
        </ul>
        <p>Host starts when all are ready.</p>
      </div>
    </section>
    <section class="panel">
      <header>Tips</header>
      <div class="body">
        <p>Performance: low-poly, fog, capped DPR, snapshots ~12 Hz with client interpolation.</p>
      </div>
    </section>
  </main>
</div>

<!-- Fullscreen 3D -->
<div id="viewport"></div>
<div id="hud">SPD <span id="spd">0</span> | ALT <span id="alt">0</span></div>
<div id="fps">FPS —</div>
<div id="compass">HDG <span id="hdg">000</span>° | <span id="card">N</span></div>
<div id="hint">↑↓ pitch • ←→ yaw • SPACE boost</div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  // ====== SOCKET / ROOM ======
  const url = new URL(location.href);
  const room = url.searchParams.get("room") || "airfield";
  if(!url.searchParams.get("room")){ url.searchParams.set("room", room); history.replaceState(null,"",url.toString()); }
  const socket = io({ query:{ room }, transports:["websocket"], upgrade:true });

  let me={ id:null, hostId:null };
  const roomIdEl = document.getElementById("roomId");
  const btnStart = document.getElementById("btnStart");
  const playersEl = document.getElementById("players");
  const inpName = document.getElementById("inpName");
  const inpColor = document.getElementById("inpColor");
  const btnSet = document.getElementById("btnSet");
  const chkReady = document.getElementById("chkReady");
  const chatEl = document.getElementById("chat");
  const inpChat = document.getElementById("inpChat");
  const btnChat = document.getElementById("btnChat");
  roomIdEl.textContent = room;

  btnSet.onclick = ()=> socket.emit("player:set", { name:(inpName.value||"").slice(0,24), color: inpColor.value });
  chkReady.onchange = ()=> socket.emit("player:ready", { ready: chkReady.checked });
  btnChat.onclick = ()=>{ const text=(inpChat.value||"").trim(); if(!text) return; socket.emit("chat:send",{text}); inpChat.value=""; };
  inpChat.addEventListener("keydown", e=>{ if(e.key==="Enter") btnChat.click(); });
  btnStart.onclick = ()=> socket.emit("game:start");

  socket.on("room:joined", ({roomId,playerId,hostId})=>{
    me.id = playerId; me.hostId = hostId;
    inpName.value = "Pilot " + playerId.slice(0,4);
  });
  socket.on("room:state", (p)=>{
    me.hostId = p.hostId;
    playersEl.innerHTML = "";
    (p.players||[]).forEach(pl=>{
      const li=document.createElement("li");
      li.innerHTML = `<span class="chip" style="background:${pl.color}"></span> <strong>${esc(pl.name)}</strong> ${pl.id===p.hostId?'<span class="chip">Host</span>':''} ${pl.ready?'<span class="chip">Ready</span>':''}`;
      playersEl.appendChild(li);
    });
    btnStart.style.display = (p.state==="lobby" && me.id===p.hostId) ? "" : "none";
  });
  socket.on("chat:new", ({name,text})=>{
    const div=document.createElement("div");
    div.innerHTML=`<strong>${esc(name)}:</strong> ${esc(text)}`;
    chatEl.appendChild(div); chatEl.scrollTop = chatEl.scrollHeight;
  });
  socket.on("game:start", ()=> enterWorld());

  const esc = s => (s+"").replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

  // ====== WORLD (THREE) ======
  let renderer, scene, camera, clock;
  let DPR = Math.min(1.5, devicePixelRatio||1);
  const viewport = document.getElementById("viewport");
  const hud = document.getElementById("hud");
  const fpsEl = document.getElementById("fps");
  const compassEl = document.getElementById("compass");
  const hdgEl = document.getElementById("hdg");
  const cardEl = document.getElementById("card");
  const hintEl = document.getElementById("hint");
  const spdEl = document.getElementById("spd");
  const altEl = document.getElementById("alt");

  let local = { obj:null, color:"#7ab8ff", speed: 40, yaw:0, pitch:0, roll:0 };
  const peers = new Map(); // id -> {obj,last}

  const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, Space:false };
  window.addEventListener("keydown", (e)=>{ if(e.repeat) return; if(e.key in keys){ keys[e.key]=true; e.preventDefault(); } });
  window.addEventListener("keyup",   (e)=>{ if(e.key in keys){ keys[e.key]=false; e.preventDefault(); } });

  function enterWorld(){
    document.getElementById("lobbyScreen").style.display="none";
    viewport.style.display="block"; hud.style.display="block"; fpsEl.style.display="block"; compassEl.style.display="block"; hintEl.style.display="block";
    setTimeout(()=> hintEl.style.display="none", 4000);

    renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(DPR);
    renderer.setSize(innerWidth, innerHeight);
    viewport.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x06223f);
    scene.fog = new THREE.FogExp2(0x06223f, 0.002);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);

    // Lighting & sky
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(20,50,10); scene.add(sun);

    // Orientation aids
    addWorldOrientation(scene);

    // My “cube plane”
    local.color = inpColor.value || "#7ab8ff";
    local.obj = makeCubePlane(local.color);
    local.obj.position.set(0, 80, 0);
    scene.add(local.obj);

    // Camera follow boom
    const rig = new THREE.Object3D();
    local.obj.add(rig);
    rig.add(camera);
    camera.position.set(-0.2, 2.2, -10);
    camera.lookAt(new THREE.Vector3(10,0,0)); // forward is +X

    clock = new THREE.Clock();

    // Networking snapshots
    socket.on("state:snapshot", (arr)=>{
      const ids = new Set(arr.map(a=>a.id));
      for(const a of arr){
        if(a.id===me.id) continue;
        let o = peers.get(a.id);
        if(!o){
          const obj = makeCubePlane(a.color||"#7ab8ff");
          scene.add(obj);
          o = { obj, last:a };
          peers.set(a.id, o);
          obj.position.set(a.x,a.y,a.z);
          obj.quaternion.set(a.qx,a.qy,a.qz,a.qw);
        } else {
          o.last = a;
        }
      }
      for(const [id,o] of peers){
        if(!ids.has(id)){ scene.remove(o.obj); peers.delete(id); }
      }
    });

    tick();
  }

  function makeCubePlane(color="#7ab8ff"){
    const g = new THREE.Object3D();
    const mat = new THREE.MeshStandardMaterial({ color, metalness:0.1, roughness:0.85 });

    // body (cube)
    const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 1), mat); // X forward
    g.add(body);

    // wings (cubes)
    const wing = new THREE.Mesh(new THREE.BoxGeometry(0.3, 6, 0.3), mat);
    wing.position.set(0, 0, 0);
    g.add(wing);

    // tail (cube)
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.8, 0.4), mat);
    tail.position.set(-1.6, 0.6, 0);
    g.add(tail);

    // actuators (little cubes on wingtips + tail tip)
    const actMat = new THREE.MeshStandardMaterial({ color:"#fff", roughness:0.6 });
    const a1 = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25), actMat); a1.position.set(0, 3.2, 0); g.add(a1);
    const a2 = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25), actMat); a2.position.set(0,-3.2, 0); g.add(a2);
    const a3 = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25), actMat); a3.position.set(-2.2, 1.2, 0); g.add(a3);

    // “propeller” cube in front
    const prop = new THREE.Mesh(new THREE.BoxGeometry(0.15,1.2,0.15), new THREE.MeshStandardMaterial({color:"#eee"}));
    prop.position.set(1.7,0,0);
    g.add(prop);
    g.userData.prop = prop;

    return g;
  }

  function addWorldOrientation(scene){
    // Ground grid
    const grid = new THREE.GridHelper(4000, 80, 0x1e90ff, 0x1e90ff);
    grid.material.opacity = 0.15; grid.material.transparent = true;
    scene.add(grid);

    // Axis beams at origin
    const xBeam = new THREE.Mesh(new THREE.BoxGeometry(1000, 0.5, 0.5), new THREE.MeshBasicMaterial({color:0xff5555}));
    xBeam.position.set(500, 0.25, 0); scene.add(xBeam); // +X (east)
    const zBeam = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1000), new THREE.MeshBasicMaterial({color:0x55ff55}));
    zBeam.position.set(0, 0.25, 500); scene.add(zBeam); // +Z (south-ish for orientation)
    const yBeam = new THREE.Mesh(new THREE.BoxGeometry(0.5, 400, 0.5), new THREE.MeshBasicMaterial({color:0xaaaaaa}));
    yBeam.position.set(0, 200, 0); scene.add(yBeam);

    // Cardinal pylons with labels
    const pylons = [
      { pos:[ 0, 0, -800], color:0x00bfff, label:'N' },
      { pos:[ 800,0, 0],   color:0xff6b6b, label:'E' },
      { pos:[ 0, 0, 800],  color:0x22c55e, label:'S' },
      { pos:[-800,0, 0],   color:0xf59e0b, label:'W' },
    ];
    const textMat = new THREE.MeshBasicMaterial({color:0xffffff});
    pylons.forEach(p=>{
      const col = new THREE.Mesh(new THREE.BoxGeometry(20, 200, 20), new THREE.MeshStandardMaterial({color:p.color, roughness:1}));
      col.position.set(p.pos[0], 100, p.pos[2]);
      scene.add(col);
      // label (simple billboard plane)
      const label = new THREE.Mesh(new THREE.PlaneGeometry(60,60), new THREE.MeshBasicMaterial({color:0xffffff}));
      label.position.set(p.pos[0], 240, p.pos[2]);
      label.userData.billboard=true;
      label.userData.text=p.label;
      scene.add(label);
      // tiny beacon light
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(6,8,8), new THREE.MeshBasicMaterial({color:p.color}));
      bulb.position.set(p.pos[0], 210, p.pos[2]);
      scene.add(bulb);
    });
  }

  // Flight model (keyboard only)
  let lastSend = 0;
  function simulateLocal(dt){
    // Inputs
    const pitchIn = (keys.ArrowUp? 1:0) + (keys.ArrowDown? -1:0);  // Up = pitch up
    const yawIn   = (keys.ArrowRight? 1:0) + (keys.ArrowLeft? -1:0);
    const boost   = keys.Space? 1:0;

    // Speeds
    const accel = 25*boost - 8*(1-boost); // hold space to accelerate, otherwise gentle decay
    local.speed = THREE.MathUtils.clamp(local.speed + accel*dt, 10, 140);

    // Apply orientation (roll auto-levels toward 0)
    const obj = local.obj;
    obj.rotateX(pitchIn * 0.9 * dt);   // pitch about local X (remember our +X is forward; but geometry is X-forward, so rotate Z/Y carefully)
    obj.rotateY(yawIn   * 1.2 * dt);   // yaw about local Y
    // Auto-level roll toward 0
    const e = new THREE.Euler().setFromQuaternion(obj.quaternion, "ZYX");
    obj.rotateZ(-e.z * 0.8 * dt);

    // Move forward along +X
    const forward = new THREE.Vector3(1,0,0).applyQuaternion(obj.quaternion);
    obj.position.addScaledVector(forward, local.speed * dt);

    // Keep above “ground”
    if(obj.position.y < 20) obj.position.y = 20;

    // Spin prop
    const prop = obj.userData.prop; if(prop) prop.rotation.x += dt*30;

    // HUD
    spdEl.textContent = local.speed.toFixed(0);
    altEl.textContent = Math.max(0, obj.position.y|0);

    // Compass
    const eul = new THREE.Euler().setFromQuaternion(obj.quaternion, "YXZ");
    let deg = THREE.MathUtils.radToDeg(eul.y); // heading
    deg = (deg%360+360)%360;
    hdgEl.textContent = deg.toFixed(0).padStart(3,'0');
    cardEl.textContent = ['N','NE','E','SE','S','SW','W','NW'][Math.round(deg/45)%8];

    // Send my state ~12 Hz
    const now = performance.now();
    if(now - lastSend > 80){
      lastSend = now;
      const q = obj.quaternion, p = obj.position;
      socket.emit("state:update", {
        x:+p.x.toFixed(2), y:+p.y.toFixed(2), z:+p.z.toFixed(2),
        qx:+q.x.toFixed(4), qy:+q.y.toFixed(4), qz:+q.z.toFixed(4), qw:+q.w.toFixed(4),
        s:+local.speed.toFixed(1)
      });
    }
  }

  // Peer interpolation
  const tmpQ = new THREE.Quaternion(), curQ = new THREE.Quaternion();
  function simulatePeers(dt){
    for(const o of peers.values()){
      if(!o.last) continue;
      const p = o.obj.position;
      p.x += (o.last.x - p.x) * Math.min(1, dt*6);
      p.y += (o.last.y - p.y) * Math.min(1, dt*6);
      p.z += (o.last.z - p.z) * Math.min(1, dt*6);
      tmpQ.set(o.last.qx, o.last.qy, o.last.qz, o.last.qw).normalize();
      curQ.copy(o.obj.quaternion);
      curQ.slerp(tmpQ, Math.min(1, dt*6));
      o.obj.quaternion.copy(curQ);
      const prop = o.obj.userData.prop; if(prop) prop.rotation.x += dt*30;
    }
  }

  // Billboard labels face camera
  function updateBillboards(){
    scene.traverse(obj=>{
      if(obj.userData && obj.userData.billboard){
        obj.lookAt(camera.position);
      }
    });
  }

  // Render loop + dynamic res
  let frameCount=0, acc=0, fps=60;
  function tick(){
    const dt = Math.min(0.05, (clock?clock.getDelta():0.016));
    acc += dt; frameCount++;
    if(acc>=1){ fps = frameCount; frameCount=0; acc=0; fpsEl.textContent = `FPS ${fps}`; }
    if(fps < 45 && DPR > 1){ DPR = Math.max(1, DPR - 0.05); renderer.setPixelRatio(DPR); }
    else if(fps > 70 && DPR < (devicePixelRatio||1)){ DPR = Math.min(devicePixelRatio||1, DPR + 0.05); renderer.setPixelRatio(DPR); }

    if(local.obj){
      simulateLocal(dt);
      simulatePeers(dt);
      updateBillboards();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  // Resize
  window.addEventListener("resize", ()=>{
    if(!renderer) return;
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  });
})();
</script>
</body>
</html>
