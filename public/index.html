<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AirParty 3D</title>
<style>
  :root { --bg:#0b0f1a; --panel:#0e1530; --ink:#e8eefc; --brand:#7ab8ff; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-rows:auto 1fr;height:100%}
  header{display:flex;align-items:center;gap:8px;padding:10px 12px;background:linear-gradient(180deg,#101842,#0a1026);border-bottom:1px solid rgba(150,180,255,.2)}
  header .right{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn{border:1px solid rgba(150,180,255,.3);background:#13204a;color:var(--ink);padding:7px 10px;border-radius:10px;cursor:pointer}
  .btn.primary{background:var(--brand);color:#061022;border:none;font-weight:700}
  main{display:grid;grid-template-columns:320px 1fr 320px;gap:12px;padding:12px}
  .panel{background:var(--panel);border:1px solid rgba(150,180,255,.18);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .panel header{padding:8px 10px;background:#0b1230;border-bottom:1px solid rgba(150,180,255,.18);font-weight:700}
  .panel .body{padding:10px;flex:1;overflow:auto}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{background:#0d1636;border:1px solid rgba(150,180,255,.25);color:var(--ink);border-radius:10px;padding:8px 10px}
  .list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px}
  .chip{padding:4px 8px;background:#0c1228;border:1px solid rgba(150,180,255,.2);border-radius:999px}
  #viewport{position:fixed;inset:0;display:none;background:#000}
  #hud{position:fixed;left:12px;bottom:12px;display:none;background:rgba(10,16,38,.6);border:1px solid rgba(150,180,255,.25);padding:8px 10px;border-radius:12px;font-size:13px}
  #fps{position:fixed;right:12px;bottom:12px;display:none;background:rgba(10,16,38,.6);border:1px solid rgba(150,180,255,.25);padding:6px 8px;border-radius:8px;font-size:12px}
</style>
</head>
<body>
<div class="wrap" id="lobbyScreen">
  <header>
    <div>✈️ AirParty</div>
    <div class="right">
      <span>Room: <strong id="roomId">—</strong></span>
      <button id="btnStart" class="btn primary">Start (host)</button>
    </div>
  </header>
  <main>
    <section class="panel">
      <header>Lobby</header>
      <div class="body">
        <div class="row">
          <input id="inpName" class="input" placeholder="Your name" style="flex:1"/>
          <input id="inpColor" type="color" class="input" value="#7ab8ff" title="Plane color"/>
          <button id="btnSet" class="btn">Set</button>
          <label class="chip"><input type="checkbox" id="chkReady"> Ready</label>
        </div>
        <hr style="opacity:.25;margin:10px 0">
        <div><strong>Pilots</strong></div>
        <ul id="players" class="list"></ul>
        <hr style="opacity:.25;margin:10px 0">
        <div><strong>Chat</strong></div>
        <div id="chat" style="height:160px;overflow:auto;background:#0b1430;border:1px solid rgba(150,180,255,.2);border-radius:10px;padding:8px;"></div>
        <div class="row" style="margin-top:6px;">
          <input id="inpChat" class="input" placeholder="Message…" style="flex:1;"/>
          <button id="btnChat" class="btn">Send</button>
        </div>
      </div>
    </section>
    <section class="panel" style="grid-template-rows:auto 1fr">
      <header>Preview</header>
      <div class="body">
        <p>Choose your name & plane color, ready up, then the host will start.</p>
        <p>Controls (in flight):</p>
        <ul>
          <li>Mouse — pitch/roll (pointer lock)</li>
          <li>Q / E — yaw</li>
          <li>W / S — throttle up/down</li>
          <li>Shift — boost, Ctrl — brake</li>
          <li>Esc — unlock pointer</li>
        </ul>
      </div>
    </section>
    <section class="panel">
      <header>Tips</header>
      <div class="body">
        <p>Performance-safe: dynamic resolution, low-poly, snapshots at ~12 Hz, client-side interpolation.</p>
        <p>Fullscreen starts after lobby.</p>
      </div>
    </section>
  </main>
</div>

<!-- Fullscreen 3D -->
<div id="viewport"></div>
<div id="hud">SPD <span id="spd">0</span> | ALT <span id="alt">0</span> | YAW <span id="yaw">0</span></div>
<div id="fps">FPS —</div>

<script src="/socket.io/socket.io.js"></script>
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  // ====== SOCKET / ROOM ======
  const url = new URL(location.href);
  const room = url.searchParams.get("room") || "airfield";
  if(!url.searchParams.get("room")) { url.searchParams.set("room", room); history.replaceState(null,"",url.toString()); }
  const socket = io({ query:{ room }, transports:["websocket"], upgrade:true });

  let me={ id:null, hostId:null };
  const roomIdEl = document.getElementById("roomId");
  const btnStart = document.getElementById("btnStart");
  const playersEl = document.getElementById("players");
  const inpName = document.getElementById("inpName");
  const inpColor = document.getElementById("inpColor");
  const btnSet = document.getElementById("btnSet");
  const chkReady = document.getElementById("chkReady");
  const chatEl = document.getElementById("chat");
  const inpChat = document.getElementById("inpChat");
  const btnChat = document.getElementById("btnChat");

  roomIdEl.textContent = room;

  btnSet.onclick = ()=> socket.emit("player:set", { name: (inpName.value||"").slice(0,24), color: inpColor.value });
  chkReady.onchange = ()=> socket.emit("player:ready", { ready: chkReady.checked });
  btnChat.onclick = ()=>{ const text=(inpChat.value||"").trim(); if(!text) return; socket.emit("chat:send",{text}); inpChat.value=""; };
  inpChat.addEventListener("keydown", e=>{ if(e.key==="Enter") btnChat.click(); });
  btnStart.onclick = ()=> socket.emit("game:start");

  socket.on("room:joined", ({roomId,playerId,hostId})=>{
    me.id = playerId; me.hostId = hostId;
    inpName.value = "Pilot " + playerId.slice(0,4);
  });
  socket.on("room:state", (p)=>{
    me.hostId = p.hostId;
    playersEl.innerHTML = "";
    (p.players||[]).forEach(pl=>{
      const li = document.createElement("li");
      li.innerHTML = `<span class="chip" style="background:${pl.color}"></span> <strong>${esc(pl.name)}</strong> ${pl.id===p.hostId?'<span class="chip">Host</span>':''} ${pl.ready?'<span class="chip">Ready</span>':''}`;
      playersEl.appendChild(li);
    });
    btnStart.style.display = (p.state==="lobby" && me.id===p.hostId) ? "" : "none";
  });
  socket.on("chat:new", ({name,text})=>{
    const div = document.createElement("div");
    div.innerHTML = `<strong>${esc(name)}:</strong> ${esc(text)}`;
    chatEl.appendChild(div); chatEl.scrollTop = chatEl.scrollHeight;
  });
  socket.on("game:start", ()=> enterWorld());

  const esc = s => (s+"").replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

  // ====== WORLD (THREE) ======
  let renderer, scene, camera, clock;
  let DPR = Math.min(1.5, devicePixelRatio || 1); // cap DPR for perf
  let local = {
    obj: null, // THREE.Object3D for my plane
    color: "#7ab8ff",
    speed: 30,
    yaw: 0, pitch: 0, roll: 0
  };
  const peers = new Map(); // id -> {obj,color,last:{x,y,z,q...}, blend}
  let keys = { w:false, s:false, q:false, e:false, shift:false, ctrl:false };
  let mouse = { dx:0, dy:0, active:false };
  let lastSend = 0;

  // HUD
  const hud = document.getElementById("hud");
  const spdEl = document.getElementById("spd");
  const altEl = document.getElementById("alt");
  const yawEl = document.getElementById("yaw");
  const fpsEl = document.getElementById("fps");

  function enterWorld(){
    document.getElementById("lobbyScreen").style.display="none";
    const vp = document.getElementById("viewport");
    vp.style.display="block"; hud.style.display="block"; fpsEl.style.display="block";

    renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(DPR);
    renderer.setSize(innerWidth, innerHeight);
    vp.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x06223f);
    // gradient sky as fog
    scene.fog = new THREE.FogExp2(0x06223f, 0.002);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 2, -8);

    // Lights (cheap)
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5,10,5);
    scene.add(dir);

    // Ground grid (really cheap)
    const grid = new THREE.GridHelper(2000, 40, 0x0b4, 0x0b4);
    grid.material.opacity = 0.15; grid.material.transparent = true;
    scene.add(grid);

    // Build my plane
    local.color = inpColor.value || "#7ab8ff";
    local.obj = makePlane(local.color);
    scene.add(local.obj);

    // Camera follow rig
    const rig = new THREE.Object3D();
    rig.position.set(0,0,0);
    local.obj.add(rig);
    rig.add(camera);
    camera.position.set(0, 2.2, -8);
    camera.lookAt(new THREE.Vector3(0,0,10));

    clock = new THREE.Clock();

    // Pointer lock for mouse flight
    renderer.domElement.addEventListener("click", ()=>{
      if(document.pointerLockElement !== renderer.domElement){
        renderer.domElement.requestPointerLock();
        document.documentElement.requestFullscreen().catch(()=>{});
      }
    });
    document.addEventListener("pointerlockchange", ()=>{ mouse.active = (document.pointerLockElement === renderer.domElement); });
    document.addEventListener("mousemove", (e)=>{
      if(!mouse.active) return;
      mouse.dx += e.movementX;
      mouse.dy += e.movementY;
    });

    // Keys
    window.addEventListener("keydown", (e)=>{ if(e.repeat) return; handleKey(e.key.toLowerCase(), true); });
    window.addEventListener("keyup",   (e)=>{ handleKey(e.key.toLowerCase(), false); });
    function handleKey(k,down){
      if(k==='w') keys.w=down; if(k==='s') keys.s=down;
      if(k==='q') keys.q=down; if(k==='e') keys.e=down;
      if(k==='shift') keys.shift=down; if(k==='control') keys.ctrl=down;
    }

    // Networking: receive snapshots
    socket.on("state:snapshot", (arr)=>{
      // ensure we have objects for peers
      const ids = new Set(arr.map(a=>a.id));
      for(const a of arr){
        if(a.id===me.id) continue; // we simulate locally
        let o = peers.get(a.id);
        if(!o){
          const obj = makePlane(a.color||"#7ab8ff");
          scene.add(obj);
          o = { obj, color:a.color||"#7ab8ff", last:a, blend:0 };
          peers.set(a.id, o);
        } else {
          o.color = a.color||o.color;
          o.last = a;
          o.blend = 0; // reset interpolation blend
        }
      }
      // cleanup missing peers
      for(const [id,o] of peers){
        if(!ids.has(id)){ scene.remove(o.obj); peers.delete(id); }
      }
    });

    // Start loop
    tick();
  }

  function makePlane(color="#7ab8ff"){
    // Low-poly plane: fuselage + wings + tail
    const group = new THREE.Object3D();
    const mat = new THREE.MeshStandardMaterial({ color, metalness:0.1, roughness:0.8 });
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 3.2, 2, 8), mat);
    body.rotation.z = Math.PI/2;
    group.add(body);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 0.05), mat);
    wing.position.set(0,0,0);
    group.add(wing);
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.4, 0.6), mat);
    tail.position.set(-1.8, 0.4, 0);
    group.add(tail);
    const prop = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1, 0.05), new THREE.MeshStandardMaterial({ color:"#fff" }));
    prop.position.set(2.0,0,0);
    group.add(prop);
    group.userData.prop = prop;
    return group;
  }

  // Simple flight model (arcade)
  function simulateLocal(dt){
    // Mouse controls -> pitch/roll
    const sens = 0.0018;
    const yawRate = 0.6; // rad/s from Q/E
    local.pitch = THREE.MathUtils.clamp(local.pitch - mouse.dy*sens, -1.0, 1.0);
    local.roll  = THREE.MathUtils.clamp(local.roll  - mouse.dx*sens, -1.0, 1.0);
    mouse.dx = mouse.dy = 0;

    // Yaw
    let yawInput = 0; if(keys.q) yawInput -= 1; if(keys.e) yawInput += 1;
    local.yaw += yawInput * yawRate * dt;

    // Throttle
    const accel = (keys.w? 20:0) - (keys.s? 20:0);
    local.speed = THREE.MathUtils.clamp(local.speed + accel*dt, 10, 120);
    if(keys.shift) local.speed = Math.min(140, local.speed + 20*dt);
    if(keys.ctrl)  local.speed = Math.max(5, local.speed - 30*dt);

    // Apply orientation
    const obj = local.obj;
    // Smooth orientation toward inputs
    obj.rotateZ(local.roll * 1.8 * dt);     // roll
    obj.rotateX(local.pitch * 1.4 * dt);    // pitch
    obj.rotateY(local.yaw * 1.2 * dt);      // yaw (relative)

    // Move forward along -Z of object? Our body is X-forward due to geometry; align:
    const forward = new THREE.Vector3(1,0,0).applyQuaternion(obj.quaternion);
    obj.position.addScaledVector(forward, local.speed * dt);

    // keep above ground
    if(obj.position.y < 20) obj.position.y = 20;

    // spin prop
    const prop = obj.userData.prop; if(prop) prop.rotation.x += dt*20;

    // Update HUD
    spdEl.textContent = local.speed.toFixed(0);
    altEl.textContent = Math.max(0, obj.position.y|0);
    // yaw approx from quaternion
    const eul = new THREE.Euler().setFromQuaternion(obj.quaternion, "YXZ");
    yawEl.textContent = THREE.MathUtils.radToDeg(eul.y).toFixed(0);
  }

  // Interpolate peers toward last snapshot
  const tmpQ = new THREE.Quaternion(), curQ = new THREE.Quaternion();
  function simulatePeers(dt){
    for(const o of peers.values()){
      if(!o.last) continue;
      // position
      const p = o.obj.position;
      p.x += (o.last.x - p.x) * Math.min(1, dt*6);
      p.y += (o.last.y - p.y) * Math.min(1, dt*6);
      p.z += (o.last.z - p.z) * Math.min(1, dt*6);
      // rotation slerp
      tmpQ.set(o.last.qx, o.last.qy, o.last.qz, o.last.qw).normalize();
      curQ.copy(o.obj.quaternion);
      curQ.slerp(tmpQ, Math.min(1, dt*6));
      o.obj.quaternion.copy(curQ);
      // prop spin
      const prop = o.obj.userData.prop; if(prop) prop.rotation.x += dt*20;
    }
  }

  // Networking: send my state at ~12 Hz
  function maybeSend(now){
    if(now - lastSend < 80) return;
    lastSend = now;
    const q = local.obj.quaternion;
    const p = local.obj.position;
    socket.emit("state:update", {
      x:+p.x.toFixed(2), y:+p.y.toFixed(2), z:+p.z.toFixed(2),
      qx:+q.x.toFixed(4), qy:+q.y.toFixed(4), qz:+q.z.toFixed(4), qw:+q.w.toFixed(4),
      s:+local.speed.toFixed(1)
    });
  }

  // Render loop with dynamic resolution
  let frameCount=0, acc=0, fps=60;
  function tick(){
    const dt = Math.min(0.05, clock.getDelta()); // clamp dt to avoid spikes
    acc += dt; frameCount++;
    if(acc>=1){ fps = frameCount; frameCount=0; acc=0; fpsEl.textContent = `FPS ${fps}`; }
    // Dynamic resolution scale if FPS too low/high
    if(fps < 45 && DPR > 1){ DPR = Math.max(1, DPR - 0.05); renderer.setPixelRatio(DPR); }
    else if(fps > 70 && DPR < (devicePixelRatio||1)){ DPR = Math.min(devicePixelRatio||1, DPR + 0.05); renderer.setPixelRatio(DPR); }

    if(local.obj){
      simulateLocal(dt);
      simulatePeers(dt);
      // place camera a bit behind local plane (already parented)
      maybeSend(performance.now());
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  // handle resize
  window.addEventListener("resize", ()=>{
    if(!renderer) return;
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  });
})();
</script>
</body>
</html>
